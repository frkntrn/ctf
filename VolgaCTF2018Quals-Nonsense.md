```python
import hashlib
import gmpy2
import os
from secret import x, seed


class DSA():
	def __init__(self):
		self.g = 88125476599184486094790650278890368754888757655708027167453919435240304366395317529470831972495061725782138055221217302201589783769854366885231779596493602609634987052252863192229681106120745605931395095346012008056087730365567429009621913663891364224332141824100071928803984724198563312854816667719924760795
		self.y = 18433140630820275907539488836516835408779542939919052226997023049612786224410259583219376467254099629677919271852380455772458762645735404211432242965871926570632297310903219184400775850110990886397212284518923292433738871549404880989194321082225561448101852260505727288411231941413212099434438610673556403084
		self.p = 89884656743115795425395461605176038709311877189759878663122975144592708970495081723016152663257074178905267744494172937616748015651504839967430700901664125135185879852143653824715409554960402343311756382635207838848036159350785779959423221882215217326708017212309285537596191495074550701770862125817284985959
		self.q = 1118817215266473099401489299835945027713635248219
		self.x = x

	def sign(self, m, k):
		h = int(hashlib.md5(m).hexdigest(), 16)
		r = pow(self.g, k, self.p) % self.q
		s = int(((self.x * r + h) * gmpy2.invert(k, self.q)) % self.q)
		return (r, s)

	def verify(self, m, r, s):
		if 0 < r and r < self.q and 0 < s and s < self.q:
			h = int(hashlib.md5(m).hexdigest(), 16)
			w = gmpy2.invert(s, self.q)
			u1 = (h * w) % self.q
			u2 = (r * w) % self.q
			v = ((pow(self.g, u1, self.p) * pow(self.y, u2, self.p)) % self.p) % self.q
			return v == r
		return None


class LCG():
	def __init__(self):
		self.a = 3437776292996777467976657547577967657547
		self.b = 828669865469592426262363475477574643634
		self.m = 1118817215266473099401489299835945027713635248219
		self.seed = seed
		self.state = (self.a * self.seed + self.b) % self.m

	def next_number(self):
		self.state = (self.a * self.state + self.b) % self.m
		return self.state


generator = LCG()
signature = DSA()

for _ in range(2):
	message = "VolgaCTF{" + os.urandom(16).encode('hex') + "}"
	k = generator.next_number()
	(r, s) = signature.sign(message, k)
	print (message, r, s)
	print signature.verify(message, r, s)
  ```
  </br>
  
  ```python
  ('VolgaCTF{nKpV/dmkBeQ0n9Mz0g9eGQ==}', 1030409245884476193717141088285092765299686864672, 830067187231135666416948244755306407163838542785)
('VolgaCTF{KtetaQ4YT8PhTL3O4vsfDg==}', 403903893160663712713225718481237860747338118174, 803753330562964683180744246754284061126230157465)
('VolgaCTF{8NXrNihQFZHXN/aLQeYKtg==}', 573204611556272128788136170196175308321188191436, 91103585122319085944642441222968347176761155259)
('VolgaCTF{uDh3jKDKW2utTkblP43NQw==}', 988208923601321592314278832250352152086708201148, 535902494423594375360085340272213659149931817732)
('VolgaCTF{gtE4LCuhT5drcDunvKz/oQ==}', 398664332680411743333343859695363011153860369916, 392831307484494740050270232580899453387203218646)
('VolgaCTF{rS9IEsyvXHOCUo0/TL2c1A==}', 1069308776596602518230279648695605679674084062212, 1092197517441497735860968374670599451237193808469)
('VolgaCTF{4gEh/j9EGwZ20NEoBieDbQ==}', 299126738734367538949359921058714964192219834697, 1033663138335940105270395993670462206279669465530)
('VolgaCTF{RwpewhJhMGH0MORFtXQfAw==}', 45947153576235029841784762518202071246619636555, 160232137675713914067049553022084774145041067326)
('VolgaCTF{i7QjVusEQboUz2tPx/Uxkw==}', 158481243947457932495342738131507924205209157088, 260728631055453998945003114392349125641429319965)
('VolgaCTF{nQwf/+78QMObu3S3Oh1Olg==}', 117030185689896730023482874167356847173848413476, 645757721193000290408806214518814010431656731046)
```
Soruda bize yukarıdaki kod ve imzalar verilmiş, anahtarı bulmamız istenmiş. **LCG** fonksiyonunda ardışık anahtarlar arasındaki doğrusal bağıntı verilmiş, **sign** fonksiyonundaki 3. denklemi ve 2 imza kullanarak anahtarı elde edebiliriz.</br></br>
![](https://latex.codecogs.com/gif.latex?s_{1}k=x_{1}r+h_{1}(modq))</br>
![](https://latex.codecogs.com/gif.latex?s_{2}(ak+b)=x_{2}r+h_{2}(modq))</br></br>

**m** ve **q** eşit olduğundan yukarıdaki iki denklemi yazabiliriz. Geriye sadece denklemi çözüp, **x**'i bulmak kaldı.

```python
import hashlib
sayiya_cevir = lambda m: int(hashlib.md5(m).hexdigest(), 16)

h1 = sayiya_cevir('VolgaCTF{nKpV/dmkBeQ0n9Mz0g9eGQ==}'); h2 = sayiya_cevir('VolgaCTF{KtetaQ4YT8PhTL3O4vsfDg==}')
r1 = 1030409245884476193717141088285092765299686864672 ; r2 = 403903893160663712713225718481237860747338118174
s1 = 830067187231135666416948244755306407163838542785  ; s2 = 803753330562964683180744246754284061126230157465

a = 3437776292996777467976657547577967657547
b = 828669865469592426262363475477574643634
q = 1118817215266473099401489299835945027713635248219

from gmpy import invert
cozum = ((a*h1*s2 - h2*s1 + b*s1*s2)*invert(r2*s1 - a*r1*s2, q)) % q

print(hex(cozum)[2:])
```
**9d529e2da84117fe72a1770a79cec6ece4065212**






